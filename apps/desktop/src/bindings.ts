// @ts-nocheck
/* eslint-disable */
// This file was generated by tauri-specta. Do not edit manually.
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async getGitSnapshot(repoPath: string): Promise<Result<GitSnapshot, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_git_snapshot', { repoPath }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCommitHistory(
    repoPath: string,
    limit: number | null,
  ): Promise<Result<HistoryCommit[], ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_commit_history', { repoPath, limit }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCommitFiles(repoPath: string, commitId: string): Promise<Result<FileItem[], ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_commit_files', { repoPath, commitId }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCommitFileVersions(
    repoPath: string,
    commitId: string,
    relPath: string,
    previousPath: string | null,
  ): Promise<Result<FileVersions, ApiError>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_commit_file_versions', {
          repoPath,
          commitId,
          relPath,
          previousPath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getFileVersions(
    repoPath: string,
    relPath: string,
    bucket: Bucket,
  ): Promise<Result<FileVersions, ApiError>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_file_versions', { repoPath, relPath, bucket }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async stageFile(repoPath: string, relPath: string): Promise<Result<null, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('stage_file', { repoPath, relPath }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async unstageFile(repoPath: string, relPath: string): Promise<Result<null, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('unstage_file', { repoPath, relPath }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async stageAll(repoPath: string): Promise<Result<null, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('stage_all', { repoPath }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async unstageAll(repoPath: string): Promise<Result<null, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('unstage_all', { repoPath }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async discardFile(
    repoPath: string,
    relPath: string,
    bucket: Bucket,
  ): Promise<Result<null, ApiError>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('discard_file', { repoPath, relPath, bucket }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async discardFiles(repoPath: string, files: DiscardFileInput[]): Promise<Result<null, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('discard_files', { repoPath, files }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async discardAll(repoPath: string): Promise<Result<null, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('discard_all', { repoPath }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async commitStaged(repoPath: string, message: string): Promise<Result<string, ApiError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('commit_staged', { repoPath, message }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
}

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type ApiError = { code: ErrorCode; message: string; details: string | null }
export type Bucket = 'unstaged' | 'staged' | 'untracked'
export type DiffFile = { name: string; contents: string }
export type DiscardFileInput = { relPath: string; bucket: Bucket }
export type ErrorCode = 'INVALID_INPUT' | 'INVALID_STATUS' | 'BACKEND'
export type FileItem = { path: string; previousPath: string | null; status: FileStatus }
export type FileStatus =
  | 'added'
  | 'deleted'
  | 'renamed'
  | 'copied'
  | 'type-changed'
  | 'unmerged'
  | 'modified'
  | 'untracked'
export type FileVersions = { oldFile: DiffFile | null; newFile: DiffFile | null }
export type GitSnapshot = {
  repoRoot: string
  branch: string
  unstaged: FileItem[]
  staged: FileItem[]
  untracked: FileItem[]
}
export type HistoryCommit = {
  commitId: string
  shortId: string
  summary: string
  author: string
  relativeTime: string
}

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

type __EventObj__<T> = {
  listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> = { status: 'ok'; data: T } | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      }
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          },
        })
      },
    },
  )
}
